## 项目进度状态

| 项目名称   | 完成状态                  | 详细进度                          |
|------------|--------------------------|----------------------------------|
| Project 1  | 🔵 部分完成               | ✅ （1）已完成  ❌ （2）未完成    |
| Project 2  | 🟢 全部完成               | ✅  已完成                  |
| Project 3  | 🔴 未完成                 | ❌  未完成                   |
| Project 4  | 🔵 部分完成               | ✅ （1）已完成  ❌ （2）（3）未完成  |
| Project 5  | 🔵 部分完成               | ✅ （1）已完成  ❌ （2）（3）未完成  |
| Project 6  | 🔴 未完成                 | ❌  未完成                  |



## Project 1: 做SM4的软件实现和优化 
#### a): 从基本实现出发 优化SM4的软件执行效率，至少应该覆盖T-table、AESNI以及最新的指令集（GFNI、VPROLD等）（已完成）
- 使用T-table优化sm4思路：将S盒变换与后续的循环移位变换L进行合并，定义四个8bit-->32bit查找表。
- 使用AESNI优化sm4思路：使用SIMD指令进行多个分组数据的并行处理，并使用AESENCLAST实现SM4的S盒变换（借助有限域的同构映射）。
- sm4未优化，使用T-table优化sm4，使用T-table优化sm4三者测试得到时间如下图：
  <img width="640" height="345" alt="image" src="https://github.com/user-attachments/assets/1fdb0677-64f7-4c34-bbf8-904a4e5b7fa9" />
- 结果分析表格如下：
  
|                | sm4未优化 | T-table优化sm4 | AESNI优化sm4 |
|----------------|----------|---------------|---------------|
| **平均耗时**       | 875ns    | 670ns         | 4326ns        |
| **性能**           | 基准     | ↑23.4%        | ↓394%         |
| **性能差异原因**   | \        | 减少实时计算；提高缓存命中率；消除分支预测 | 转换开销大；测试数据规模较小未能体现优势 |<br><br>


## Project 2: 基于数字水印的图片泄露检测 
#### 编程实现图片水印嵌入和提取（可依托开源项目二次开发），并进行鲁棒性测试，包括不限于翻转、平移、截取、调对比度等
- 采取的水印鲁棒性增强技术如下：

| 技术分类         | 实现方法/函数                | 技术原理                                                                 | 抵抗的攻击类型               |
|------------------|-----------------------------|--------------------------------------------------------------------------|----------------------------|
| **纠错编码**      | `hamming74_encode()`<br>`hamming74_decode()` | 使用(7,4)汉明码实现数据冗余和错误校正，每个4位数据编码为7位，可纠正1位错误 | 噪声干扰、压缩失真         |
| **频域选择**      | `get_lowfreq_positions()`   | 在DCT变换域的低频系数嵌入水印（跳过DC分量），提高对常规图像处理的抵抗能力  | JPEG压缩、滤波操作         |
| **冗余嵌入**      | `repeat`参数（默认5次）      | 每个编码比特在多个位置重复嵌入，通过多数表决机制提高提取准确性              | 局部裁剪、涂改攻击         |
| **几何校正**      | `align_image_by_features()` | 采用ORB特征检测+RANSAC单应矩阵计算实现图像自动对齐                          | 旋转、缩放、平移等几何攻击 |
| **通道选择**      | Y通道嵌入                   | 在YCrCb色彩空间的亮度通道(Y)而非色度通道嵌入，提高视觉不可见性和稳定性       | 色彩调整、色度压缩         |
| **分散嵌入**      | 全局低频系数分布             | 水印比特分散在图像所有8x8块的低频系数中，避免集中存储                       | 局部破坏、区域删除         |
| **自适应强度**    | `alpha`参数（默认0.25）      | 动态调整水印嵌入强度，平衡不可见性和鲁棒性                                 | 对比度调整、亮度变化       |

- 原始图像，添加水印后的图像，采取四种攻击（rotate,cut,contrast,crop）得到的图像如下所示：
<img width="2281" height="442" alt="image" src="https://github.com/user-attachments/assets/9474963a-88a9-41ea-bc7e-f075e97b7014" />

- 抗鲁棒性测试结果如下图：
<img width="702" height="449" alt="image" src="https://github.com/user-attachments/assets/8e850bbe-cd71-4299-a2a0-e99d1003f52f" />

  
- 结果分析表格如下：

| 攻击类型          | 参数设置               | 平均比特准确率 | 鲁棒性分析                                                                 |
|-------------------|-----------------------|---------------|----------------------------------------------------------------------------|
| **未攻击（对照）**     | -                     | 100.00%       | 水印系统基础功能完整，无失真条件下可完全提取                                |
| **rotate（旋转10°）**  | 旋转中心=(256,256)<br>旋转角度=10° | 79.17%        | 对几何攻击敏感，但仍有较强恢复能力                  |
| **cut（左上角切除）**  | 切除区域=0:256×0:256<br>放大至512×512 | 87.50%        | 局部破坏未导致水印失效            |
| **contrast（对比度增强）** | alpha=1.5<br>beta=0   | 100.00%       | 完全抵抗色彩空间调整，频域嵌入对亮度变化具有强鲁棒性                        |
| **crop（中心区域裁剪）** | 裁剪区域=128:384×128:384<br>放大至512×512 | 60.42%        | 中心区域水印受损严重                      |



## Project 4: SM3的软件实现与优化 
## a）：与Project 1类似，从SM3的基本软件实现出发，参考付勇老师的PPT，不断对SM3的软件执行效率进行改进
- 采用的优化技术如下表：
  
| 优化技术                | 说明                                                                 | 性能提升效果                     |
|-------------------------|----------------------------------------------------------------------|----------------------------------|
| **预计算常量**          | 提前计算并存储Tj循环左移j位的值，避免每轮重复计算                      | 减少64次循环内的位运算操作       |
| **消息扩展展开**        | 提前完成W[j]和W'[j]的计算，避免按需计算                              | 消除分支预测失败，提高指令连续性 |
| **循环展开**            | 将64轮压缩展开为16组4轮并行处理                                      | 减少循环控制开销，提高指令级并行 |
| **寄存器变量**          | 使用局部寄存器变量A-H替代数组访问                                   | 减少内存访问，提高寄存器利用率   |
| **宏函数内联**          | 使用宏替换小型函数调用，消除调用开销                                  | 减少栈操作和跳转指令             |
| **延迟计算**            | 按需计算消息扩展值（后改为提前计算）                                  | 减少不必要计算（实际效果不佳）   |
| **位运算优化**          | 使用安全的rotl32替代直接移位操作                                      | 保证正确性的同时保持高效位操作   |
| **内存访问优化**        | 确保W/W'数组顺序访问，提高缓存命中率                                  | 提升数据局部性                   |
| **并行计算**            | 在每轮中并行处理SS1/SS2和TT1/TT2                                     | 更好地利用CPU流水线              |

- 测试结果如下图所示：
  <img width="881" height="344" alt="5a74fed9ea130615793bbd1263efef8b" src="https://github.com/user-attachments/assets/c564ffa3-ea2f-46dc-93cb-cba1a5e2b1d5" />

## b）：基于sm3的实现，验证length-extension attack（未完成）
## c）：基于sm3的实现，根据RFC6962构建Merkle树（10w叶子节点），并构建叶子的存在性证明和不存在性证明（未完成）
